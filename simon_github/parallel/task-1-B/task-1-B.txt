Данная реализация гарантирует взаимное исключение.
Как только один из потоков атомарно увеличит thread_count , другой поток будет бесконечно находиться в wait секции (цикле while) , пока наш первый поток не освободит мьютекс в unlock и не уменьшит значение thread_count.
В противном случае перевес в положительную сторону значения переменной thread_count , созднанный захватившим мьютекс 1-ым потоком (thread.fetch_add(1) в условии while) так и не нарушится , соответственно условие в while будет всегда выполняться.
Свобода же от взаимной блокировки в общем случае не гарантируется, уже при большем ,чем 2 кол-ве потоков может происходить такая ситуация, когда не один из потоков не может захватить мьютекс и потоки вечно крутятся в wait секции.
Пример:
Пусть все 3 потока попробуют захватить mutex.
Первый дошедший из потоков действительно спокойно захватит мьютекс, так как thread_count = 0 изначально, и поток не зайдёт в while , присвоив переменной thread_count значение 1.
Пусть теперь поток 2 и 3 попробуют захватить мьютекс.Сначала поток 2 зайдёт в цикл while , увеличив значение thread_count на 1, затем планировщик даст управление 3 потоку, он также зайдёт в цикл while увеличив thread_count на 1.
Теперь даже если 1 поток отпустит мьютекс значение у перменной thread_count будет 2.
Теперь не трудно подобрать последовательно переключений, при которых потоки 2 и 3 бесконечно долго крутятся в while.
2 поток выполняет декремент(thread_count.fetch_sub(1) ) и заново заходит в while , в котором делает fetch_add(1). 
Затем планировшик отдаёт управление 3 потоку, которое делает тоже самое, что и 2. И такое чередование явно не позволит кому-то выйти из while. 
Если какой то новый поток попробудет захватить Мьютекс, он также застрянет в wait секции. 
Наверное на практике бесконечно долго так продолжться не будет, но чисто теоретически данный мьютекс не гарантирует свободу от взаимной блокировки.
